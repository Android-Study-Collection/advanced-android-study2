---
title: Refactoring - 악취
type: slide
slideOptions: 
    center: false
---

# Refactoring - 악취

---

- 악취(Smell)란 무엇일까요?

---

- 악취(Smell)란 무엇일까요?
    - 냄새가 난다.
    - 기저귀 냄새 by 켄트 벡
    - '적용 방법'을 아는 것과 '제때 적용'할 줄 아는 것은 다르다.
    - 리팩토링을 '언제'해야할 지 시점을 파악할 수 있다.

---

## 악취

- Mysterious Name
    - 코딩은 추리 소설이 아니다. (What & How 포함된 네이밍 필요)
    - 가장 어렵기로 손꼽히는 두 가지 중 하나 ~~(나머지는 캐시 무효화)~~
- Duplicated Code
    - 같은 구조의 코드가 여러 군데 있으면 하나로 통합하여 나은 프로그램을 만들 수 있다.

---

- Long Function
    - 간접 호출(Indirection)의 효과(이해, 공유, 선택하기 쉬워짐)는 짧은 함수일 때 나온다.
    - 요즘 언어는 서브루틴에 대한 비용이 거의 없다.
    - 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.(주석으로 설명하려던 코드를 담고, 함수이름을 동작방식이 아닌 의도가 드러나게 짓는다)

---

- Long Parameter List
    - 매개변수를 질의함수로 바꾸기/객체 통째로 넘기기/매개변수 객체 만들기/플래그 인수 제거하기/여러 함수를 클래스로 묶기
- Global Data)
    - 어디서든 건들 수 있고, 값을 누가 바꿔는지 찾아내기 힘들다.
      (유령 같은 원격작용, Spooky action at a distance)
    - 악취 중 가장 지독한 축에 속한다.
    - 클래스 변수와 싱글톤도 같은 동일한 문제이다.

---

- Mutable Data(가변 데이터)
    - 데이터 변경 시 버그가 발생하는 경우가 있을 수 있다.
    - 함수형 언어에서는 원 데이터는 그대로 둔 채, 복사본을 만들어 반환하는 식으로 되어 있다.

---

- Divergent Change(뒤엉킨 변경)
    - 코드를 수정할 때는 한 군데를 찾아 그 부분만 수정하기를 기대한다.
    - 단일 책임 원칙(SRP, Single Responsibility Principle)이 제대로 지켜지지 않았을 때 나타난다.
    - 하나를 추가/변경/삭제 할 때, 연관된 함수를 여러개 바꿔야하는 모듈이 있다면, 뒤엉킨 변경이 발생한 것이다.
    - 산탄총 수술(Shotgun Surgery)의 반대다.

---

단일 책임 원칙

> 단일 모듈은 변경의 이유가 하나, 오직 하나여야만 한다.
or
> '단일 모듈은 오직 하나의 액터(actor)에 대해서만 책임져야 한다.' (from Clean Architecture)

---

- Shotgun Surgery(산탄총 수술)
    - 뒤엉킨 변경과 비슷하면서도 정반대다.
    - 코드 변경을 할 때마다 *자잘하게* 수정해야 하는 클래스가 많을 때 풍긴다.

---

- Feature Envy(기능 편애)
    - 모듈화 시에 영역 안에서 상호작용은 최대한 늘리고 영역 간 이뤄지는 상호작용은 최소화한다.
    - 기능 편애는 자기가 속한 모듈의 함수나 데이터보다 다른 모듈과 더 상호작용을 할 때 풍긴다.

- Data Clumps(데이터 뭉치)
    - 같이 뭉쳐 다니는 데이터
    - 뭉치인지 판별하려면, 데이터를 하나 삭제해본다. 나머지 데이터만으로 의미가 없다면 객체로 묶어야할 뭉치이다.

---

- Primative Obsession(기본형 집착)
    - primitive type들과 날짜 등의 라이브러리에서 제공되는 객체에 집착하는 것
    - 프로그래밍 중에는 자신에게 맞는 타입을 꺼리는 사람이 많다.
    - `if(a < upper && a > lower)`

---

- Repeated Switches
    - 순수 객체 지향 신봉자들은 switch문의 사악함(switch문은 모조리 없애야할 대상이다!라고)을 주장한다. 심지어 if문도.
    - 지금은 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중
    - 중복된 switch 조건문이 문제되는 이유는 조건절을 추가할 때마다 다른 switch문들도 같이 수정해야하기 떄문이다.

---

- Loops
    - 1970년대의 나팔바지나 솜털 무늬 벽지보다 못한 존재가 됨.
    - 지금은 일급 함수(First-class function)를 지원하는 언어가 많아졌다.

- Lazy Element(성의 없는 요소)
    - 요소란 method, class, interface 등 구조를 위한 포맷들을 말한다.
    - 본문 코드를 그대로 쓰는 것과 진배없는 함수, 메서드가 하나 뿐인 클래스

---

- Speculative Generality(추측성 일반화)
    - '나중에 필요할 거야'
    
- Temporary Field
    - 객체를 사용할 때는 객체 값이 있을 거라고 기대한다.

---

- Message Chain
    - 체인: 하나의 객체에서 객체를 얻은 뒤 또 다른 객체를 요청하는 식
    - 연쇄적으로 이어지는 코드
    - `managerName = aPerson.department.manager.name`
    - 메서드 체인을 무조건 나쁘게 생각하는 사람들도 있다.

---

- Middel Man
    - 객체의 대표적인 기능 하나인 캡슐화에서 위임이 자주 활용된다.
        ex. 팀장에게 미팅을 요청한다. 우리는 팀장이 어떻게 요청하는지 알 필요가 없다.
    - 클래스 내에서 다른 클래스를 위한 구현을 더 많이하는 경우, 위임이 지나치다.

---

- Insider Trading
    - 모듈 간의 거래를 줄이고 투명하게 해야한다.

- Large Class
    - 한 클래스가 너무 많은 일을 하려다 보면 커지고, 중복코드가 생기기 쉽다.
    
- Alternatives Classes with Different Interfaces
    - 클래스의 장점은 교체할 수 있다는 것. 그러려면 인터페이스가 같아야한다.

---

- Data Class
    - 저장 용도로만 쓰다보니 다른 클래스가 너무 관여할 때가 많다.

- Refused Bequest(상속 포기)
    - 부모의 유산을 원치 않는다거나 선택적으로 원하지만, 인터페이스를 따르고 있지 않을 때 냄새가 난다.

---

- Comments(주석)
    - 주석은 달아도 된다. 주석은 향기를 입힌다.
    - 주석을 탈취제처럼 사용하지 말자. 주석이 많은 이유는 코드를 잘못 작성했기 때문.

---

- Mysterious Name
    - 함수 선언 바꾸기/변수 이름 바꾸기/필드 이름 바꾸기
- Duplicated Code
    - 함수 추출하기/문장 슬라이드하기/메서드 올리기
- Long Function
    - 함수 추출하기/임시 변수를 질의 함수로 바꾸기/매개변수 객체 만들기/객체 통째로 넘기기/함수를 명령으로 바꾸기/조건문 분해하기/조건부 로직을 다형성으로 바꾸기/반복문 쪼개기
- Long Parameter List
    - 매개변수를 질의함수로 바꾸기/객체 통째로 넘기기/매개변수 객체 만들기/플래그 인수 제거하기/여러 함수를 클래스로 묶기
- Global Data
    - 변수 캡슐화하기
- Mutable Data(가변 데이터)
    - 변수 캡슐화하기/변수 쪼개기/문장 슬라이드하기/함수 추출하기/질의 함수와 변경 함수 분리하기/세터 제거하기/파생 변수를 질의 함수로 바꾸기/여러 함수를 클래스로 묶기/여러 함수를 변환 함수로 묶기/참조를 값으로 바꾸기
- Divergent Change(뒤엉킨 변경)
    - 단계 쪼개기/함수 옮기기/함수 추출하기/클래스 추출하기
- Shotgun Surgery(산탄총 수술)
    - 함수 옮기기/필드 옮기기/여러 함수를 클래스로 묶기/여러 함수를 변환 함수로 묶기/단계 쪼개기/함수 인라인하기/클래스 인라인하기
- Feature Envy(기능 편애)
    - 함수 옮기기/함수 추출하기
    - 디자인 패턴 중 전략 패턴(Strategy Pattern), 방문자 패턴(Visitor Pattern)
    - 켄트 벡의 자기 위임(Self Delegation)
- Data Clumps(데이터 뭉치)
    - 클래스 추출하기/매개변수 객체 만들기/객체 통째로 넘기기
- Primative Obsession(기본형 집착)
    - 기본형을 객체로 바꾸기/타입 코드를 서브클래스로 바꾸기/조건부 로직을 다형성으로 바꾸기/클래스 추출하기/매개변수 객체 만들기
- Repeated Switches
    - 조건부 로직을 다형성으로 바꾸기
- Loops
    - 반복문을 파이프라인으로 바꾸기(filter, map)
- Lazy Element(성의 없는 요소)
    - 함수 인라인하기/클래스 인라인하기/계층 합치기
- Speculative Generality(추측성 일반화)
    - 계층 합치기/함수 인라인하기/크래스 인라인하기/함수 선언 바꾸기/죽은 코드 제거하기
- Temporary Field
    - 클래스 추출하기/함수 옮기기/특이 케이스 추가하기
- Message Chain
    - 위임 숨기기/함수 추출하기/함수 옮기기
- Middle Man
    - 중재자 제거하기/함수 인라인하기
- Insider Trading(내부자 거래)
    - 함수 옮기기/필드 옮기기/위임 숨기기/서브클래스를 위임으로 바꾸기/슈퍼클래스를 위임으로 바꾸기
- Large Class
    - 클래스 추출하기/슈퍼클래스 추출하기/타입 코드를 서브클래스로 바꾸기
- Alternative Classes with Different Interfaces
    - 함수 선언 바꾸기/함수 옮기기/슈퍼클래스 추출하기
- Data Class
    - 레코드 캡슐화하기/세터 제거하기/함수 옮기기/함수 추출하기/단계 쪼개기
- Refused Bequest(상속 포기)
    - 메서드 내리기/필드 내리기/서브클래스를 위임으로 바꾸기/슈퍼클래스를 위임으로 바꾸기
- Comments(주석)
    - 함수 추출하기/함수 선언 바꾸기/어서션 추가하기
